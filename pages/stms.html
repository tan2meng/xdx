<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•†åº—å®¢æµè®¡æ•°å™¨ (AI Webcam)</title>
    <!-- å¼•å…¥ TensorFlow.js å’Œ COCO-SSD æ¨¡å‹ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'LXGW WenKai TC', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            margin-bottom: 10px;
            color: #333;
        }

        .stats-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
        }

        .in-count {
            color: #2ecc71;
        }

        .out-count {
            color: #e74c3c;
        }

        .video-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            background: #000;
        }

        /* è§†é¢‘å’ŒCanvasé‡å  */
        video {
            display: block;
            width: 640px;
            height: 480px;
            transform: scaleX(-1);
            /* é•œåƒç¿»è½¬ï¼Œç¬¦åˆé•œå­ä¹ æƒ¯ */
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            transform: scaleX(-1);
            /* Canvasä¹Ÿè¦é•œåƒ */
        }

        #status {
            margin-top: 10px;
            color: #666;
            font-style: italic;
        }

        button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:disabled {
            background-color: #ccc;
        }
    </style>
</head>

<body>

    <h1>ğŸ›’ å•†åº—å®¢æµç›‘æµ‹ç³»ç»Ÿ</h1>

    <div class="stats-container">
        <div class="stat-box">
            <span class="stat-value in-count" id="count-in">0</span>
            <span class="stat-label">è¿›å…¥ (In)</span>
        </div>
        <div class="stat-box">
            <span class="stat-value out-count" id="count-out">0</span>
            <span class="stat-label">ç¦»å¼€ (Out)</span>
        </div>
        <div class="stat-box">
            <span class="stat-value" id="current-people">0</span>
            <span class="stat-label">å½“å‰ç”»é¢äººæ•°</span>
        </div>
    </div>

    <div class="video-container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
    </div>

    <p id="status">æ­£åœ¨åŠ è½½ AI æ¨¡å‹...</p>
    <button id="resetBtn">é‡ç½®è®¡æ•°</button>

    <script>
        // é…ç½®å‚æ•°
        const CONFIDENCE_THRESHOLD = 0.6; // ç½®ä¿¡åº¦é˜ˆå€¼
        const IOU_THRESHOLD = 0.3; // ç”¨äºè¿½è¸ªçš„é‡å /è·ç¦»åˆ¤æ–­é˜ˆå€¼

        // å…¨å±€å˜é‡
        let video;
        let canvas;
        let ctx;
        let model;
        let inCount = 0;
        let outCount = 0;

        // è¿½è¸ªé€»è¾‘å˜é‡
        // previousObjects ç»“æ„: { id: { x, y, firstX } }
        let previousObjects = {};
        let nextObjectId = 0;
        const CENTER_LINE_X = 320; // 640å®½åº¦çš„ä¸­é—´
        const LINE_WIDTH = 20; // åˆ¤å®šç¼“å†²åŒºçš„å®½åº¦

        // åˆå§‹åŒ–
        async function init() {
            video = document.getElementById('webcam');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            const status = document.getElementById('status');

            try {
                // 1. è·å–æ‘„åƒå¤´æµ
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 },
                    audio: false
                });
                video.srcObject = stream;

                // ç­‰å¾…è§†é¢‘åŠ è½½å…ƒæ•°æ®ä»¥è·å–å°ºå¯¸
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });

                // 2. åŠ è½½ COCO-SSD æ¨¡å‹
                status.innerText = "æ¨¡å‹åŠ è½½ä¸­ï¼Œè¯·ç¨å€™... (åˆæ¬¡åŠ è½½å¯èƒ½è¾ƒæ…¢)";
                model = await cocoSsd.load();
                status.innerText = "ç³»ç»Ÿè¿è¡Œä¸­ | è¯·ç¡®ä¿å…‰çº¿å……è¶³";

                // 3. å¼€å§‹æ£€æµ‹å¾ªç¯
                detectFrame();
            } catch (error) {
                console.error(error);
                status.innerText = "é”™è¯¯ï¼šæ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–åŠ è½½æ¨¡å‹ã€‚è¯·ç¡®ä¿ä½¿ç”¨HTTPSæˆ–localhostã€‚";
            }
        }

        // æ ¸å¿ƒæ£€æµ‹å¾ªç¯
        async function detectFrame() {
            // ä½¿ç”¨æ¨¡å‹è¿›è¡Œé¢„æµ‹
            const predictions = await model.detect(video);

            // è¿‡æ»¤ï¼šåªä¿ç•™ 'person' ç±»åˆ«
            const people = predictions.filter(p => p.class === 'person' && p.score > CONFIDENCE_THRESHOLD);

            // æ›´æ–° UI å’Œ æ•°æ®
            document.getElementById('current-people').innerText = people.length;

            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶æ£€æµ‹çº¿ (å±å¹•ä¸­é—´å‚ç›´çº¿)
            drawDetectionLine();

            // è¿½è¸ªä¸è®¡æ•°é€»è¾‘
            processTracking(people);

            // ä¸‹ä¸€å¸§
            requestAnimationFrame(detectFrame);
        }

        function drawDetectionLine() {
            ctx.beginPath();
            ctx.moveTo(CENTER_LINE_X, 0);
            ctx.lineTo(CENTER_LINE_X, canvas.height);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 4;
            ctx.stroke();

            // ç»˜åˆ¶æ–‡å­—æ ‡è®°æ–¹å‘
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '16px "LXGW WenKai TC"';
            ctx.fillText("è¿›å…¥ >>>", CENTER_LINE_X + 10, 30);
            ctx.fillText("<<< ç¦»å¼€", CENTER_LINE_X - 70, 30);
        }

        // ç®€å•çš„è¿½è¸ªç®—æ³• (åŸºäºè´¨å¿ƒè·ç¦»)
        function processTracking(currentDetections) {
            let currentObjects = {};

            currentDetections.forEach(detection => {
                const [x, y, w, h] = detection.bbox;
                const centerX = x + w / 2;
                const centerY = y + h / 2;

                // 1. å°è¯•åŒ¹é…ä¹‹å‰çš„å¯¹è±¡ ID
                let matchedId = null;
                let minDistance = Infinity;

                for (let id in previousObjects) {
                    const prevObj = previousObjects[id];
                    // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»
                    const dist = Math.hypot(centerX - prevObj.x, centerY - prevObj.y);

                    // å¦‚æœè·ç¦»å¤Ÿè¿‘ï¼Œè®¤ä¸ºæ˜¯åŒä¸€ä¸ªäºº
                    if (dist < 100 && dist < minDistance) { // 100px æ˜¯å…è®¸çš„æœ€å¤§ç§»åŠ¨è·ç¦»
                        minDistance = dist;
                        matchedId = id;
                    }
                }

                // 2. å¦‚æœæ²¡åŒ¹é…åˆ°ï¼Œèµ‹äºˆæ–° ID
                if (matchedId === null) {
                    matchedId = nextObjectId++;
                }

                // 3. è®°å½•å½“å‰å¸§çš„å¯¹è±¡çŠ¶æ€
                // æˆ‘ä»¬éœ€è¦ä¿ç•™ firstX (è¯¥IDæœ€åˆå‡ºç°çš„Xåæ ‡) æ¥è¾…åŠ©åˆ¤æ–­ï¼Œæˆ–è€…ä¿ç•™ä¸Šä¸€å¸§çš„çŠ¶æ€
                // è¿™é‡Œç®€å•ç‚¹ï¼šå¦‚æœå®ƒæ˜¯å·²å­˜åœ¨çš„IDï¼Œæ£€æŸ¥æ˜¯å¦è·¨è¶Šäº†ä¸­çº¿
                if (previousObjects[matchedId]) {
                    const prevX = previousObjects[matchedId].x;
                    checkCrossing(matchedId, prevX, centerX);
                }

                currentObjects[matchedId] = { x: centerX, y: centerY };

                // ç»˜åˆ¶è¾¹æ¡†å’Œ ID
                drawBox(detection, matchedId);
            });

            // æ›´æ–°å†å²è®°å½• (ä¸¢å¤±çš„å¯¹è±¡ä¼šè¢«è‡ªåŠ¨ä¸¢å¼ƒ)
            previousObjects = currentObjects;
        }

        function checkCrossing(id, prevX, currX) {
            // å®šä¹‰ä¸€ä¸ªç¼“å†²åŒºï¼Œé˜²æ­¢äººåœ¨çº¿ä¸ŠæŠ–åŠ¨å¯¼è‡´é‡å¤è®¡æ•°
            // å·¦è¾¹åŒºåŸŸ < CENTER_LINE_X < å³è¾¹åŒºåŸŸ

            // é€»è¾‘ï¼šä¸Šä¸€å¸§åœ¨å·¦è¾¹ï¼Œå½“å‰å¸§åœ¨å³è¾¹ -> è¿›å…¥
            if (prevX < CENTER_LINE_X && currX >= CENTER_LINE_X) {
                inCount++;
                updateUI();
                flashLine('green');
            }

            // é€»è¾‘ï¼šä¸Šä¸€å¸§åœ¨å³è¾¹ï¼Œå½“å‰å¸§åœ¨å·¦è¾¹ -> ç¦»å¼€
            if (prevX > CENTER_LINE_X && currX <= CENTER_LINE_X) {
                outCount++;
                updateUI();
                flashLine('red');
            }
        }

        function drawBox(detection, id) {
            const [x, y, w, h] = detection.bbox;

            // æ¡†
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);

            // æ ‡ç­¾
            ctx.fillStyle = '#00FFFF';
            ctx.fillRect(x, y - 20, w, 20); // èƒŒæ™¯æ¡

            ctx.fillStyle = '#000000';
            ctx.font = '14px Arial';
            ctx.fillText(`Person ID: ${id}`, x + 5, y - 5);

            // è´¨å¿ƒç‚¹
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(x + w / 2, y + h / 2, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        function updateUI() {
            document.getElementById('count-in').innerText = inCount;
            document.getElementById('count-out').innerText = outCount;
        }

        // è§†è§‰åé¦ˆæ•ˆæœ
        function flashLine(color) {
            const originalStyle = ctx.strokeStyle;
            ctx.strokeStyle = color;
            setTimeout(() => { ctx.strokeStyle = originalStyle; }, 200);
        }

        document.getElementById('resetBtn').addEventListener('click', () => {
            inCount = 0;
            outCount = 0;
            nextObjectId = 0;
            previousObjects = {};
            updateUI();
        });

        // å¯åŠ¨
        init();

    </script>
</body>

</html>